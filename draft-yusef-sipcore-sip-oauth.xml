<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc subcompact="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc-ext allow-markup-in-artwork="yes" ?>
<!DOCTYPE rfc [
]>

<rfc ipr="pre5378Trust200902"
     docName="draft-yusef-sipcore-sip-oauth-03"
     category="std"
     xml:lang="en"
     updates="3261">


<!-- ********************************** FRONT ********************************** -->
<front>

  <title>The Session Initiation Protocol (SIP) OAuth</title>

  <author initials="R." surname="Shekh-Yusef" fullname="Rifaat Shekh-Yusef" role="editor">
    <organization>Avaya</organization>
    <address>
      <postal>
        <street>250 Sidney Street</street>
        <city>Belleville</city>
        <region>Ontario</region>
        <country>Canada</country>
      </postal>
      <phone>+1-613-967-5267</phone>
      <email>rifaat.ietf@gmail.com</email>
    </address>
  </author>

  <author initials="V." surname="Pascual" fullname="Victor Pascual">
    <organization>Oracle</organization>
    <address>
      <postal>
        <street />
        <region></region>
        <country>Spain</country>
      </postal>
      <email>victor.pascual.avila@oracle.com</email>
    </address>
  </author>

  <author initials="C." surname="Holmberg" fullname="Christer Holmberg">
    <organization>Ericsson</organization>
    <address>
      <postal>
        <street>Hirsalantie 11</street>
        <city>Jorvas  02420</city>
        <region></region>
        <country>Finland</country>
      </postal>
      <email>christer.holmberg@ericsson.com</email>
    </address>
  </author>

  <date year="2015" />
  <area>RAI</area>
  <workgroup>SIPCore</workgroup>
  <keyword>SIP OAuth</keyword>
  <keyword>Authorization Framework</keyword>

  <abstract><t>
     This document defines an authorization framework for SIP that is
     based on the OAuth 2.0 framework, and adds a simple identity layer on
     top of that, based on the OpenID Connect Core 1.0, to enable Clients
     to verify the identity of the End-User based on the authentication
     performed by an Authorization Server, as well as to obtain basic
     profile information about the End-User.
  </t></abstract>

</front>



<!-- ********************************** MIDDLE ********************************** -->
<middle>

  <section title="Introduction" anchor="introduction">

    <t>
      The SIP protocol <xref target="RFC3261"/> uses the framework used by the HTTP
      protocol for authenticating users, which is a simple challenge-
      response authentication mechanism that allows a server to challenge a
      client request and allows a client to provide authentication
      information in response to that challenge.
    </t>

    <t>
      The SIP protocol does not have an authorization framework to allow
      the system to control access to various services provided by the
      system.
    </t>

    <t>
      OAuth 2.0 <xref target="RFC6749" /> defines a token based authorization framework to
      allow clients to access resources on behalf of their user. It also
      defines four types of authorization grants, which the client uses to
      request the access token.
    </t>

    <t>
      The OpenID Connect 1.0 <xref target="OPENID" /> specifications defines a simple
      identity layer on top of the OAuth 2.0 protocol, which enables
      Clients to verify the identity of the End-User based on the
      authentication performed by an Authorization Server, as well as to
      obtain basic profile information about the End-User.
    </t>

    <t>
      This document defines an authorization framework for SIP that is
      based on the OAuth 2.0 framework, and adds the identity layer on top
      of that, based on the OpenID Connect Core 1.0 specification
    </t>

    <section title="Terminology" anchor="terminology">
      <t>
      The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
      "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
      interpreted as described in <xref target="RFC2119" />.
      </t>
    </section>

    <section title="Definitions" anchor="definitions">
    <t><list>

      <t>
      Types of SIP services:
      <list style="symbols">
        <t>Basic SIP Services: make/receive call, transfer, call forward, etc.</t>
        <t>Advanced SIP Services: services provided by SIP application servers,
           e.g. Voice Mail, Conference Services, Presence, IM, ... </t>
      </list>
      </t>

      <t>
      Single Sign-On (SSO)
      <list><t>
        SSO is a property that allows the user to be authenticated once
        and as a result have access to multiple services in the system.
      </t></list>
      </t>

      <t>
      Authentication
      <list><t>
        The process of verifying the identity of a user trying to get
        access to some network services.
      </t></list>
      </t>

      <t>
      Authorization
      <list><t>
        The process of controlling an authenticated user access to network services and
        the level of service provided to the user.
      </t></list>
      </t>

    </list></t>

    <t> <vspace blankLines="1" /> </t>

    </section>



    <section title="Use Cases" anchor="use.cases">


      <section title="Enterprise SSO" anchor="enterprise.sso">
        <t>
          An enterprise is interested in providing its users with an SSO
          capability to the various corporate services. The enterprise has an
          authorization server for controlling the user access to their network
          and would like to extend that existing authorization server to
          control the user access to the various services provided by their SIP
          network.
        </t>

        <t>
          The user is expected to provide his corporate credentials to login to
          the corporate network and get different types of services, regardless
          of the protocol used to provide the service, and without the need to
          create different accounts for these different types of services.
        </t>

        <t>
          See <xref target="authorization.code.grant.type"/> for the grant type that
          addresses this use case.
        </t>

        <t> <vspace blankLines="99" /> </t>

      </section>


      <section title="3GPP" anchor="three.gpp">

        <t>
          The 3GPP network interested in allowing a user using a WebRTC IMS Client (WIC)
          to authenticate to a WebRTC Authorization Function (WAF) and in response be given
          an access token that allows the user to register and get service from the 3GPP
          SIP network.
        </t>

        <t>
          The WIC downloads an IMS webpage from the WebRTC Web Server Function (WWSF) using
          HTTP. The WIC then requests an access token from the WAF using HTTP, which the WIC
          then uses to register to the SIP network throught the P-CSCF enhanced for WebRTC (eP-CSCF)
          element.
        </t>

        <t>
          See <xref target="implicit.grant.type"/> for the grant type that
          addresses this use case.
        </t>

        <t> <vspace blankLines="1" /> </t>

      </section> <!-- 3GPP -->


      <section title="SIP SSO" anchor="sip.sso">

        <t>
          An enterprise is interested in providing its users with an SSO
          capability to the various corporate SIP services.
        </t>

        <t>
          The enterprise wants to control the services provided to their SIP
          users and the level of service provided to the user by their SIP
          application servers without the need to create different accounts for
          these services.
        </t>

        <t>
          The enterprise wants to utilize an existing authentication mechanism
          provided by SIP, but would like to be able to control who gets access
          to what service and when.
        </t>

        <t>
          The user is expected to use his SIP credentials to login to the SIP
          network and get access to the basic services, and to get access to
          the services provided by the various SIP application servers without
          being challenged to provide credentials for each type of service.
        </t>

        <t>
          See <xref target="resource.owner.password.credentials.grant.type"/> for
          the grant type that addresses this use case.
        </t>

        <t> <vspace blankLines="99" /> </t>

      </section> <!-- SIP SSO -->



    </section>


    <section title="Roles" anchor="roles">
    <t><list>

      <t>
      resource owner
      <list><t>
        An entity capable of granting access to a protected resource. When
        the resource owner is a person, it is referred to as an end-user.
      </t></list>

      <list><t>
        In a typical SIP network, it is the management element in the system
        that acts as a resource owner.
      </t></list>
      </t>

      <t>
      resource server
      <list><t>
        The server hosting the protected resources or services, capable of accepting
        and responding to protected resource and services requests using access tokens.
      </t></list>
      </t>

      <t>
      OAuth 2.0 client
      <list><t>
        An application making protected resource requests on behalf of the
        resource owner and with its authorization.  The term "client" does
        not imply any particular implementation characteristics (e.g.,
        whether the application executes on a server, a desktop, or other
        devices).
      </t></list>
      </t>

      <t>
      SIP client
      <list><t>
        An application making requests to access SIP services on behalf of the end-user.
      </t></list>
      </t>

      <t>
      authorization server
      <list><t>
        The server issuing tokens to the OAuth 2.0 client or SIP Client after
        successfully authenticating the resource owner and obtaining
        authorization.
      </t></list>
      </t>

      <t>
      proof-of-possession (pop)
      <list><t>
        A hash used by one party to prove to another party that it is in
        possession of some shared credentials, without sending the
        credentials on the wire.
      </t></list>
      </t>

    </list></t>

    <t> <vspace blankLines="1" /> </t>
    </section>


    <section title="ID Token" anchor="id.token">

    <t>
      ID token, as defined in the OpenID document, is a security token that contains
      claims about the authentication of an end-user by an authorization server.
    </t>

    </section>


    <section title="Authentication Types" anchor="authentication.types">
    <t>

    There are two types of user authentications in SIP:

    <list style="symbols">
      <t>Proxy-to-User: which allows a server that is providing a service to
         authenticate the identity of a user before providing the service.
      </t>

      <t>User-to-User: which allows a user recieving a request to authenticate
         the identity of the remote user before processing the request.
      </t>
    </list>

    The mechanism defined in this document addresses the proxy-to-user authentication only.
    For user-to-user authentication refer to the mechanism defined in [STIR].

    </t>

    <t> <vspace blankLines="1" /> </t>
    </section>

  </section> <!-- Introduction -->


  <section title="Benefits" anchor="benefits">
  <t>
  This section describes the benefit of this authorization framework:
  </t>

    <section title="Single Sign-On" anchor="single.sign.on">
    <t>
      With the existing mechanism, the proxy and application servers might
      need to challenge many of the requests sent by a client, which adds
      traffic that could be avoided with this authorization mechanism.
    </t>

    <t>
      Single Sign-On is a property that allows the user to be authenticated
      once and as a result have access to multiple services in the system.
    </t>

    <t>
      This authorization mechanism would enable Single Sign-On, as the user
      will be authenticated once and as a result given a token and a
      refresh token to allow the user access to various services based on
      the token scope.
    </t>
    </section>

    <section title="Service Authorization" anchor="service.authorization">
    <t>
      This authorization mechanism allows the system to centrally control the
      services provided to the user, e.g conference services, voice mail, etc.
      The mechanism also allow control over the level of services provided to
      the user; for example, if the user is given access to conference services,
      the system controls whether the user gets access to video conference services
      or only audio conference services.
    </t>
    </section>

    <section title="Third-Party Authentication" anchor="third.party.authentication">
    <t>
      This authorization mechanism allows the user to be authenticated and
      obtain tokens using some Third-Party Authorization mechanism and still
      get services from the system.
    </t>

    <t> <vspace blankLines="1" /> </t>
    </section>

  </section> <!-- Benefits -->


  <section title="Authorization Code Grant type" anchor="authorization.code.grant.type">



    <section title="Operations Overview" anchor="operations.overview">

    <t>
      The following figure provides a high level view of flow of messages
      for the Authorization Code Grant type:
    </t>

<figure><artwork>
<![CDATA[

Authentication
--------------

User                            Proxy                   Authorization
Agent                                                          Server
---------------------------------------------------------------------
  |                               |                               |
  | F1 REGISTER                   |                               |
  |------------------------------>|                               |
  |                        F2 401 |                               |
  |<------------------------------|                               |
  |                               |                               |
  | F3 GET /authorize?response_type=code&...                      |
  |-------------------------------------------------------------->|
  |                               |                        F4 401 |
  |<--------------------------------------------------------------|
  |                               |                               |
  |                               |                               |
o master-key = HMAC-SHA256(HA1, realm + nonce)                    |
  |                               |                               |
  | F5 GET /authorize?response_type=code&... with credentials     |
  |-------------------------------------------------------------->|
  |                               |                               |
  |                               |                               |
  |                      o master-key=HMAC-SHA256(HA1, realm + nonce)
  |                               |                               |
  |                               |                 F6 200 [code] |
  |<--------------------------------------------------------------|
  |                               |                               |
  |                               |                               |

]]>
</artwork></figure>

    <t> <vspace blankLines="99" /> </t>

<figure><artwork>
<![CDATA[

Registration
------------

User                            Proxy                   Authorization
Agent                                                          Server
---------------------------------------------------------------------
  |                               |                               |
  | F7 REGISTER code, pop         |                               |
  |------------------------------>|                               |
  |                               | F8 POST /token [code]         |
  |                               |------------------------------>|
  |                               |                               |
  |                               | F9 200 OK [ id-token,         |
  |                               |             access_token,     |
  |                               |             refresh_token]    |
  |                               |<------------------------------|
  |                               |                               |
  |                               |                               |
  |                               | F10 GET /userinfo [access_token]
  |                               |------------------------------>|
  |                               |                               |
  |                               | F11 200 OK [ user-info,       |
  |                               |             master-key]       |
  |                               |<------------------------------|
  |                               |                               |
  |                    F12 200 OK |                               |
  |<------------------------------|                               |
  |                               |                               |
  |                               |                               |



Subsequent Requests
-------------------

  |                               |                               |
o pop = HMAC-SHA256(master-key, digest-string)                    |
  |                               |                               |
  | F13 INVITE pop                |                               |
  |------------------------------>|                               |
  |                               |                               |
  |                               |                               |
  |               o The proxy verifies the pop.                   |
  |                               |                               |
  |              F14 180 Ringing  |                               |
  |<------------------------------|                               |
  |                               |                               |

]]>
</artwork></figure>

    <t> <vspace blankLines="99" /> </t>

<figure><artwork>
<![CDATA[

Token Refresh
-------------

User                            Proxy                   Authorization
Agent                                                          Server
---------------------------------------------------------------------
  |                               |                               |
  |                               | F15 POST /token               |
  |                               |   [ grant_type=refresh_token& |
  |                               |     refresh_token=<ref_token> |
  |                               |------------------------------>|
  |                               |                               |
  |                               |  F16 200 OK [ access_token,   |
  |                               |               refresh_token ] |
  |                               |<------------------------------|
  |                               |                               |
  |                               |                               |

]]>
</artwork></figure>


    <t>
      The UA initially sends a REGISTER request (F1) without providing any credentials.
    </t>

    <t>
      The proxy challenges the UA by responding with 401 (F2) that includes
      the address of the Authorization Server.
    </t>

    <t>
      [[OPEN ISSUE]]

      How should the UA be redirected to the Authorization Server:
      1. New SIP parameter?
      2. Extend the Bearer scheme?
      3. Define a new Scheme?
    </t>


    <t>
      The UA will then contact the Authorization Server without providing
      any credentials in the first request (F3). The Authorization Server
      challenges the request using the Digest scheme (F4), and the client
      retries the request (F5) and provides the user's credentials.
    </t>

    <t>
      The Authorization Server verifies the request from the client; if the
      verification is successful, the Authorization Server responds with
      200 OK (F6) and includes a code in the body part.
    </t>

    <t>
      The UA then retries the request (F7) and include the code in the body
      of the request. The proxy then contacts the Authorization Server and
      exchanges the code for tokens (F8 and F9), and gets the user information
      (F10 and F11). The proxy then sends 200 OK to the UA to complete the
      registration process.
    </t>

    <t> <vspace blankLines="99" /> </t>

    </section> <!-- Operations Overview -->


    <section title="Authentication" anchor="authentication">

    <t>
      The UA initiates the process by sending a REGISTER request (F1) to
      the proxy. The proxy will redirect the UA to the Authorization Server
      by responding with 401 (F2) that includes the address of the
      Authorization Server in the form of an HTTP URI.
    </t>


    <t>
      The UA constructs the initial request (F3) to the Authorization Server
      without providing any user credentials, but with the following URI
      parameters in the query component:
    </t>

    <t>
      response_type (REQUIRED)
      <list><t>Value MUST be set to "code".</t></list>
    </t>

    <t>
    user_id (REQUIRED)
      <list><t>The user's identification with the Authorization Server.</t></list>
    </t>

    <t>
      scope (OPTIONAL)
      <list><t>The scope of the access request</t></list>
    </t>

    <t>
      state (RECOMMENDED)
      <list><t>
        The value of this parameter is a nonce created by the client to
        prevent replay attack. The nonce is a uniquely generated value for
        each request. This parameter might not be included with the
        initial request that does not include credentials (F3).
      </t></list>
    </t>

    <t>
      The Authorization Server uses the user identification specified in the user_id
      parameter to verify that the user has an account in the system, and
      then challenges the request by responding with 401 (F4) with Digest scheme.
    </t>

    <t>
      The UA will generate a master-key that is based on an HMAC-Hash
      algorithm, e.g. HMAC-SHA256, that takes an input the user's HA1 and
      the concatenation of realm and nonce received in the challenge from
      the server.
    </t>

    <t>
      The UA will then send a new authorization request (F5), but this time
      include the credentials requested by the server. The UA will use the
      same parameters values used in the initial authorization request with
      the exception of the state parameter which will get a new nonce value.
    </t>

    <t>
      When the server receives the request with the credentials (F5), the
      server will verify the digest provided by the UA; if that is
      successful, the server will respond with 200 OK (F6) and include a code
      in the body of the response with the following parameters:
    </t>

    <t>
      grant_type (REQUIRED)
      <list><t>Value MUST be set to "authorization_code".</t></list>
    </t>

    <t>
      code (REQUIRED)
      <list><t>The authorization code received from the authorization server.</t></list>
    </t>

    <t>
      The server then generates a master-key that is based on an HMAC-Hash
      algorithm, e.g. HMAC-SHA256, that takes an input the user's HA1, and
      the concatenation of realm and nonce sent in the challenge (F4) to
      the client.
    </t>

    <t> <vspace blankLines="1" /> </t>

    </section> <!-- Authentication -->


    <section title="Registration" anchor="registration">

    <t>
      The UA will send a new REGISTER request (F7) and include the code in
      the body of the request with the following parameters:
    </t>

    <t>
      grant_type (REQUIRED)
      <list><t>Value MUST be set to "authorization_code".</t></list>
    </t>

    <t>
      code (REQUIRED)
      <list><t>The authorization code received from the authorization server.</t></list>
    </t>


    <t>
      The proxy sends a POST request (F8) to the Authorization Server and
      include the following parameters in the body:
    </t>

    <t>
      grant_type (REQUIRED)
      <list><t>Value MUST be set to "authorization_code".</t></list>
    </t>

    <t>
      code (REQUIRED)
      <list><t>The authorization code received from the authorization server.</t></list>
    </t>

    <t>
      If the request is valid and authorized, the authorization server
      responds with a 200 OK (F9) with id_token, access token, and refresh_token in the body.
    </t>

    <t>
      The UA sends a GET request (F10) to the Authorization Server to fetch the user
      information, and includes the access token in the body of the request. In  response
      the Autorization Server will respond with 200 OK and include the user information and
      the master-key associated with the user in the body part.
    </t>

    <t>
      The proxy then responds with 200 OK (F12) to the UA to complete the registration process.
    </t>

    <t> <vspace blankLines="1" /> </t>

    </section> <!-- Registration -->


    <section title="Subsequent Requests" anchor="subsequent.requests">

    <t>
      When the UA wants to send any request to the proxy, it MUST include
      the Authorization header and use the Bearer scheme to carry the
      proof-of-possession of the master-key.
    </t>

    <t>
      The pop is calculated using the master-key as follows:
      <list><t>pop = HMAC-SHA256(master-key, digest-string)</t></list>
    </t>


    <t>
      The following is an example of an Authorization header with Bearer scheme:
      <list><t>Authorization: Bearer pop=&lt;pop></t></list>
    </t>

    <t>
      See rfc4474, section 9, for the SIP headers to hash to create digest-string.
    </t>

    <t>
      [[OPEN ISSUE]] The Bearer scheme is used to deliver tokens without
      providing any proof of possession. We probably need to use different scheme later on.
    </t>

    <t> <vspace blankLines="1" /> </t>

    </section> <!-- Subsequent Requests -->


    <section title="Token Refresh" anchor="token.refresh">

    <t>
      The proxy makes a refresh request to the Authorization Server by sending a
      refresh POST request (F13) that includes a body with the grant_type and the
      refresh_token.
    </t>

    <t>
      For example:
      <list><t>grant_type=refresh_token&amp;refresh_token=&lt;refresh_token></t></list>
    </t>

    <t>
      If the proxy fails to refresh the token, then it MUST challenge the
      next request from the UA, and as a result the UA MUST go through the
      authorization process again to obtain new tokens.
    </t>

    <t> <vspace blankLines="1" /> </t>

    </section> <!-- Token Refresh -->


    <section title="Services" anchor="services">

    <t>
      When the UA tries to access a service on behalf of a user, e.g. Voice
      Mail Service, the proxy forwards the request to the server providing
      the service and MUST include an Authorization header with the Bearer
      scheme that carries the token needed to get service, as follows:
    </t>

    <t>
      <list><t>Authorization: Bearer token=&lt;token></t></list>
    </t>

    <t> <vspace blankLines="99" /> </t>

    </section> <!-- Services -->

  </section> <!-- Authorization Code Grant type -->



  <section title="Implicit Grant Type" anchor="implicit.grant.type">

    <t>
      The impicit grant type is used by the SIP UA to directly obtain access
      tokens from the Authorization Server to be able to register and get
      service from the SIP network.
    </t>

    <t>
      This grant type does not support the issuance of refresh tokens, which
      means that the SIP UA must re-authenticate again to the Authorization
      Server to get a new token before the current token expires.
    </t>

    <t> <vspace blankLines="1" /> </t>

    <section title="OAuth Implicit Grant" anchor="oauth.implicit.grant">

      <section title="Overview" anchor="oauth.implicit.grant.overview">

      <t>
        The following figure provides a high level view of flow of messages
        for the OAuth Implicit Grant type:
      </t>


<figure><artwork>
<![CDATA[

Authentication
--------------

User                            Proxy                   Authorization
Agent                                                          Server
---------------------------------------------------------------------
  |                               |                               |
  | F1 GET /authorize?response_type=token...                      |
  |-------------------------------------------------------------->|
  |                               |                               |
  |                               |                        F2 401 |
  |<--------------------------------------------------------------|
  |                               |                               |
  |                               |                               |
  | F3 GET /authorize?response_type=token +credentials            |
  |-------------------------------------------------------------->|
  |                               |                               |
  |                               |      F4 200 OK [access_token] |
  |<--------------------------------------------------------------|
  |                               |                               |
]]>
</artwork></figure>

<figure><artwork>
<![CDATA[
Registration
------------

  |                               |                               |
  | F5 REGISTER username@domain.com, access_token                 |
  |------------------------------>|                               |
  |                               |    F6 POST /introspect        |
  |                               |        [token=<access_token>] |
  |                               |------------------------------>|
  |                               |                               |
  |                               |                     F7 200 OK |
  |                               |<------------------------------|
  |                     F8 200 OK |                               |
  |<------------------------------|                               |
  |                               |                               |

]]>
</artwork></figure>
    </section> <!-- Overview-->

      <section title="Authentication" anchor="oauth.implicit.grant.auth">

        <t>
          The UA starts the process by sending an HTTP GET request to the
          Authorization Server without providing any credentials in the first
          request (F1).
        </t>

        <t>
          The UA constructs the initial request (F1) to the Authorization Server
          with the following URI parameters in the query component:
        </t>

        <t>
          response_type (REQUIRED)
          <list><t>Value MUST be set to "token".</t></list>
        </t>

        <t>
        user_id (REQUIRED)
          <list><t>The user's identification with the Authorization Server.</t></list>
        </t>

        <t>
          scope (OPTIONAL)
          <list><t>The scope of the access request.</t></list>
        </t>

       <t> <vspace blankLines="1" /> </t>

        <t>
          The Authorization Server challenges the request using the Digest
          scheme (F2). The client retries the request (F3) and provides the user's
          credentials. In response the Authorization Server responds with
          200 OK (F4) with the Access Token in the body.
        </t>

      </section> <!-- Authentication -->

      <section title="Registration" anchor="oauth.implicit.grant.registration">

        <t>
          The UA starts the registration process with the SIP proxy by sending
          a REGISTER request (F5) with the access token it obtained in the previous
          steps (F1-F4).
        </t>

        <t>
          The UA adds the following parameters to the body of the REGISTER request:
        </t>

        <t>
          access_token (REQUIRED)
          <list><t>The access token issued by the authorization server.</t></list>
        </t>

        <t>
          token_type (REQUIRED)
          <list><t>The type of the token issued by the authorization server.
          Value is case insensitive.</t></list>
        </t>

        <t>
          expires (RECOMMENDED)
          <list><t>
            The lifetime in seconds of the access token.
          </t></list>
        </t>

        <t>
          scope (OPTIONAL)
          <list><t>The scope of the access request.</t></list>
        </t>

        <t> <vspace blankLines="1" /> </t>

        <t>
          If introspection is used <xref target="RFC7662"/>, then the proxy validates
          the access token by sending an HTTP POST request (F6), with the parameters
          sent as "application/x-www-form-urlencoded" data, to the Authorization
          Server and include the following parameters:
        </t>

        <t>
          token (REQUIRED)
          <list><t>
            The string value of the token.
          </t></list>
        </t>

        <t>
          token_type_hint (OPTIONAL)
          <list><t>
            A hint about the type of the token submitted for introspection.
          </t></list>
        </t>

        <t> <vspace blankLines="99" /> </t>

        <t>
          Authorization Server then validates the request and responds with
          200 OK (F7), with a JSON object in the body with the following parameters:
        </t>

        <t>
          active (REQUIRED)
          <list><t>
            Boolean indicator of whether or not the presented token is currently active.
          </t></list>
        </t>

        <t>
          scope (OPTIONAL)
          <list><t>The scope of the access request.</t></list>
        </t>


        <t>
          Other parameters
          <list><t>TBD.</t></list>
        </t>

        <t> <vspace blankLines="1" /> </t>

      </section> <!-- Registration -->

      <section title="Subsequent Requests" anchor="oauth.implicit.grant.subsequent.requests">
        <t>
          All subsequent requests from the UA MUST include a valid access token. The UA
          MUST obtain a new access token before the access token expiry period
          to continue to get service from the system.
        </t>

      </section> <!-- Services -->

      <section title="Services" anchor="oauth.implicit.grant.services">
        <t>
          When the proxy forwards a request from a UA to an application server, it
          makes sure to keep the access token and scope in the message to allow
          the application server to provide the proper service to the user.
        </t>

      <t> <vspace blankLines="99" /> </t>

      </section> <!-- Services -->


    </section> <!-- OAuth Implicit Grant -->


    <section title="OpenID Implicit Grant" anchor="openid.implicit.grant">

    <t>
      The following figure provides a high level view of flow of messages
      for the OpenID Implicit Grant type:
    </t>


<figure><artwork>
<![CDATA[

User                            Proxy                   Authorization
Agent                                                          Server
---------------------------------------------------------------------
  |                               |                               |
  | F1 GET /authorize?response_type=id_token%20token...           |
  |-------------------------------------------------------------->|
  |                               |                               |
  |                               |                        F2 401 |
  |<--------------------------------------------------------------|
  |                               |                               |
  | F3 GET /authorize?response_type=id_token%20token +credentials |
  |-------------------------------------------------------------->|
  |                               |                               |
  |                               |   F4 200 OK [ id-token,       |
  |                               |               access_token]   |
  |<--------------------------------------------------------------|
  |                               |                               |
  | F5 GET /userinfo [access_token]                               |
  |-------------------------------------------------------------->|
  |                               |                               |
  |                               |        F6 200 OK [ user-info] |
  |<--------------------------------------------------------------|
  |                               |                               |
  | F7 REGISTER username@domain.com, access_token                 |
  |------------------------------>|                               |
  |                               |                               |
  |                               |    F8 POST /authorize         |
  |                               |         [token=access_token ] |
  |                               |------------------------------>|
  |                               |                               |
  |                               |     F9 200 OK                 |
  |                               |<------------------------------|
  |                               |                               |
  |                    F10 200 OK |                               |
  |<------------------------------|                               |
  |                               |                               |

]]>
</artwork></figure>


    </section> <!-- OpenID Implicit Grant -->

  </section> <!-- Implicit Grant -->



  <section title="Resource Owner Password Credentials Grant type"
           anchor="resource.owner.password.credentials.grant.type">


    <section title="Operations Overview" anchor="resource.owner.operations.overview">

    <t>
      The following figure provides a high level view of flow of messages
      for the Resource Owner Password Credentials Grant type:
    </t>


<figure><artwork>
<![CDATA[

  UA                                                           Proxy
--------------------------------------------------------------------
  |                                                              |
  | F1 REGISTER                                                  |
  |------------------------------------------------------------->|
  |                                                              |
  |                              F2 401 WWW-Authenticate: Digest |
  |<-------------------------------------------------------------|
  |                                                              |
  |                                                              |
o master-key = HMAC-SHA256(HA1, realm + nonce)                   |
  |                                                              |
  | F3 REGISTER with Authorization                               |
  |------------------------------------------------------------->|
  |                                                              |
  |                                                              |
  |                    o master-key = HMAC-SHA256(HA1, realm + nonce)
  |                                                              |
  |                              F4 200 OK [token, expires, ...] |
  |<-------------------------------------------------------------|
  |                                                              |
  |                                                              |
o pop = HMAC-SHA256(master-key, token + digest-string)           |
  |                                                              |
  | F5 INVITE token, pop                                         |
  |------------------------------------------------------------->|
  |                                                              |
  |                                    o The server verifies the pop.
  |                                                              |
  |                                               F6 180 Ringing |
  |<-------------------------------------------------------------|
  |                                                              |

]]>
</artwork></figure>

    <t>
      During registration the UA initially sends a REGISTER request (F1)
      without providing any credentials.
    </t>

    <t>
      The proxy then challenges the UA by responding with 401 (F2) that
      includes the Digest scheme in the www-authenticate header.
    </t>

    <t>
      The UA will generate a master-key that is based on an HMAC-Hash
      algorithm, e.g. HMAC-SHA256, that takes an input the user's HA1 and
      the concatenation of realm and nonce received in the challenge from
      the server. The UA will continue to use the existing operation of
      handling the Digest challenge and then sends a new REGISTER request
      (F3) with the credentials to the server.
    </t>

    <t>
      When the server receives the request with the credentials (F3), the
      server will verify the digest provided by the UA; if that is
      successful, the server will accept the registration (F4) and include
      the details of the token in the response.
    </t>

    <t>
      The server then generates a master-key that is based on an HMAC-Hash
      algorithm, e.g. HMAC-SHA256, that takes an input the user's HA1, and
      the concatenation of realm and nonce sent in the challenge to the client.
    </t>

    <t>
      At the end of the above process the UA would have registered with the
      proxy and both the UA and the proxy would have created the same
      master-key without sending the master-key on the wire.
    </t>

    <t>
      Later when the UA wants to send a request to the proxy it MUST always
      include the token and SHOULD include the pop as defined in section 4.6.
    </t>

    </section> <!-- Operations Overview -->


    <section title="Registration and Acquiring Tokens"
             anchor="registration.and.acquiring.tokens">
    <t>
      The UA MUST request the access token during the registration process
      with the proxy, by including a body with the grant_type as
      "password". Initially, the UA sends a REGISTER request without
      providing any credentials.
    </t>

    <t>
      The proxy MUST then challenge the UA by responding with 401 with the
      Digest scheme in the WWW-Authenticate header.
    </t>

    <t>
      When the UA gets challenged by the proxy to provide its credentials,
      the UA MUST include its credentials in the new REGISTER request in
      the authorization header as it is done with the existing mechanism,
      and MUST include a body with the grant_type as "password".
    </t>

    <t>
      In addition, the UA MUST generate a master-key as follows:
      <list><t>master-key = HMAC-SHA256(HA1, realm + nonce)</t></list>
    </t>

    <t>
    Where
    <list style="symbols">
      <t>HA1 - this is the user's H(A1) as defined in [DIGEST].</t>
      <t>realm - this is the realm that is returned by the server in the response
         to the initial request from the UA.</t>
      <t>nonce - this is the nonce that is returned by the server in the
         response to the initial request from the UA.</t>
    </list>
    </t>

    <t>
      When the server receives the request with the credentials, the server
      will verify the digest provided by the UA; if that is successful, the
      server will accept the registration and include the details of the
      token in the response.
    </t>

    <t>
      [[OPEN ISSUE]]
      How should the tokens be transported to the UA? in the body of the 200
      OK? or a SIP header?
    </t>

    <t>
      The server then generates a master-key following the same procedure
      followed by the client.
    </t>

    <t>
      As a result of this procedure both the UA and the server would have
      created the same master-key without sending the master-key on the wire.
    </t>

    </section> <!-- Registration and Acquiring Tokens -->


    <section title="Discarding Credentials" anchor="discarding.credentials">

    <t>
      After successfully receiving the access and refresh tokens from the
      proxy, the UA SHOULD discard the user credentials.
    </t>

    </section> <!-- Discarding Credentials -->


    <section title="Token Refresh" anchor="resource.owner.token.refresh">

    <t>
      The UA makes a refresh request to the token by sending a refresh
      REGISTER request that includes the authorization header and a body
      with the grant_type, the refresh_token, and the proof-of-possession
      of the master-key.
    </t>

    <t>
      For example:
      <figure><artwork>
        <![CDATA[   grant_type=refresh_token&refresh_token=<refresh_token>&pop=<pop> ]]>
      </artwork></figure>
    </t>

    </section> <!-- Token Refresh -->


    <section title="Authenticated Requests" anchor="resource.owner.authenticated.requests">

    <t>
      When the UA wants to send any request to the proxy, it MUST include
      the Authorization header and use the Bearer scheme to carry the
      access token, and the proof-of-possession of the master-key.
   </t>

    <t>
      For example:
      <figure><artwork>
        <![CDATA[   Authorization: Bearer token=<token>, pop=<pop> ]]>
      </artwork></figure>
    </t>

    <t>
      See rfc4474, section 9, for the SIP headers to hash to create the
      value for the proof.
    </t>

    <t>
      [[OPEN ISSUE]]
      The Bearer scheme is used to deliver tokens without providing any proof
      of possession. We probably need to use different scheme later on.
    </t>

    </section> <!-- Authenticated Requests -->


    <section title="Examples" anchor="examples">

    <figure><artwork>
    <![CDATA[

   REGISTER sip:registrar.biloxi.com SIP/2.0
   Via: SIP/2.0/TCP bobspc.biloxi.com:5060;branch=z9hG4bKnashds7
   Max-Forwards: 70
   To: Bob <sip:bob@biloxi.com>
   From: Bob <sip:bob@biloxi.com>;tag=456248
   Call-ID: 843817637684230@998sdasdh09
   CSeq: 1826 REGISTER
   Contact: <sip:bob@192.0.2.4>
   Expires: 7200
   Content-Length: 19

   grant_type=password&pop=<pop>


   SIP/2.0 200 OK
   Via: SIP/2.0/TCP bobspc.biloxi.com:5060;branch=z9hG4bKnashds7
        ;received=192.0.2.4
   To: Bob <sip:bob@biloxi.com>;tag=2493k59kd
   From: Bob <sip:bob@biloxi.com>;tag=456248
   Call-ID: 843817637684230@998sdasdh09
   CSeq: 1826 REGISTER
   Contact: <sip:bob@192.0.2.4>
   Expires: 7200
   Content-Length: 0

   {
      "access_token":"2YotnFZFEjr1zCsicMWpAA",
      "token_type":"example",
      "expires_in":3600,
      "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
      "example_parameter":"example_value"
   }

    ]]>
    </artwork></figure>

    </section> <!-- Examples -->

  </section> <!-- Resource Owner Password Credentials Grant type -->





  <section title="Outbound" anchor="outbound">

  <t>
    RFC5626 defines a mechanism that allows a UA to simultaneously
    connect and establish registration with multiple outbound proxies to
    get service.
  </t>

  <t>
    This section describes that impact of outbound on this authorization mechanism.
  </t>

    <section title="Authorization Code Grant type"
             anchor="outbound.authorization.code.grant.type">
    <t>
      During initial registration with the primary proxy, the UA is able to
      get an authorization code that it will use to register with the
      primary proxy. Assuming the authorization server is shared between
      the various outbound proxies, the UA will be able to use the same
      authorization code to register with the secondary proxies and as a
      result each one of the secondary proxies will get the master-key
      associated with the user to be used for the calculation of the proof-
      of-possession.
    </t>
    </section> <!-- Authorization Code Grant type -->


    <section title="Resource Owner Password Credentials Grant type"
             anchor="outbound.resource.owner.password.credentials.grant.type">
    <t>
      During registration the proxy challenges the UA, and both the proxy
      and the UA create a master-key based on HA1, realm, and nonce. Since
      the nonce is not shared between the various proxies, it is not
      possible for the outbound proxies to use the same master-key; as a
      result, the UA is expected to maintain a master-key and token per
      outbound proxy.
    </t>
    </section> <!-- Resource Owner Password Credentials Grant type -->


  </section> <!-- Outbound -->



  <section title="Security Considerations" anchor="security.considerations">
  <t>
    <figure><artwork>
      <![CDATA[   <Security considerations text> ]]>
    </artwork></figure>
  </t>
  </section> <!-- Security Considerations -->



  <section title="IANA Considerations" anchor="iana.considerations">
  <t>
    <figure><artwork>
      <![CDATA[   <IANA considerations text> ]]>
    </artwork></figure>
  </t>
  </section> <!-- IANA Considerations -->



  <section title="Acknowledgments" anchor="acknowledgments">
  <t>
    <figure><artwork>
      <![CDATA[   <Acknowledgments text> ]]>
    </artwork></figure>
  </t>
  </section> <!-- Acknowledgments -->

</middle>



<!-- ********************************** BACK ********************************** -->
<back>

  <references title="Normative References">

    <reference anchor="RFC2119">
      <front>
        <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate Requirement Levels</title>
        <author initials="S." surname="Bradner" fullname="Scott Bradner" />
        <date month="March" year="1997" />
      </front>
      <seriesInfo name="BCP" value="14" />
      <seriesInfo name="RFC" value="2119" />
    </reference>

    <reference anchor="RFC3261">
      <front>
        <title abbrev="SIP">SIP: Session Initiation Protocol</title>
        <author initials="J." surname="Rosenberg" fullname="Jonathan Rosenberg" />
        <author initials="H." surname="Schulzrinne" fullname="Henning Schulzrinne" />
        <author initials="H." surname="Camarillo" fullname="Gonzalo Camarillo" />
        <author initials="A." surname="Johnston" fullname="Alan Johnston" />
        <author initials="J." surname="Peterson" fullname="Jon Peterson" />
        <author initials="R." surname="Sparks" fullname="Robert Sparks" />
        <author initials="M." surname="Handley" fullname="Mark Handley" />
        <author initials="E." surname="Schooler" fullname="Eve Schooler" />
        <date month="June" year="2002" />
      </front>
      <seriesInfo name="RFC" value="3261" />
    </reference>

    <reference anchor="RFC6749">
      <front>
        <title abbrev="OAuth 2.0">The OAuth 2.0 Authorization Framework</title>
        <author initials="D." surname="Hardt" fullname="Dick Hardt" />
        <date month="October" year="2012" />
      </front>
      <seriesInfo name="RFC" value="6749" />
    </reference>

    <reference anchor="OPENID">
      <front>
        <title abbrev="OpenID">OpenID Connect Core 1.0</title>
        <author initials="N." surname="Sakimura" fullname="Nat Sakimura" />
        <author initials="J." surname="Bradley" fullname="John Bradley" />
        <author initials="M." surname="Jones" fullname="Michael Jones" />
        <author initials="B." surname="de Medeiros" fullname="Breno de Medeiros" />
        <author initials="C." surname="Mortimore" fullname="Chuck Mortimore" />
        <date month="February" year="2014" />
      </front>
    </reference>

    <reference anchor="RFC7662">
      <front>
        <title abbrev="Introspection">OAuth 2.0 Token Introspection</title>
        <author initials="J." surname="Richer" fullname="Justin Richer" />
        <date month="October" year="2015" />
      </front>
      <seriesInfo name="RFC" value="7662" />
    </reference>

  </references>

</back>


</rfc>
